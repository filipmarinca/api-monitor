generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  name          String
  passwordHash  String
  role          UserRole    @default(USER)
  apiKey        String?     @unique
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  workspaces    WorkspaceMember[]
  monitors      Monitor[]
  incidents     Incident[]
  alertRules    AlertRule[]
  
  @@map("users")
}

enum UserRole {
  ADMIN
  USER
  VIEWER
}

model Workspace {
  id          String      @id @default(uuid())
  name        String
  slug        String      @unique
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  members     WorkspaceMember[]
  monitors    Monitor[]
  
  @@map("workspaces")
}

model WorkspaceMember {
  id          String      @id @default(uuid())
  workspaceId String
  userId      String
  role        MemberRole  @default(MEMBER)
  createdAt   DateTime    @default(now())
  
  workspace   Workspace   @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([workspaceId, userId])
  @@map("workspace_members")
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

model Monitor {
  id              String        @id @default(uuid())
  name            String
  url             String
  method          HttpMethod    @default(GET)
  headers         Json?
  body            Json?
  interval        Int           @default(300000) // 5 minutes in ms
  timeout         Int           @default(30000)  // 30 seconds
  enabled         Boolean       @default(true)
  
  // Validation
  expectedStatus  Int?          @default(200)
  validateSSL     Boolean       @default(true)
  jsonSchema      Json?
  bodyRegex       String?
  
  // Regions
  regions         String[]      @default(["us-east"])
  
  // Relations
  workspaceId     String
  userId          String
  
  workspace       Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  checks          Check[]
  incidents       Incident[]
  alertRules      AlertRule[]
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@map("monitors")
}

enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  PATCH
  HEAD
  OPTIONS
}

model Check {
  id              String        @id @default(uuid())
  monitorId       String
  
  // Request
  region          String
  requestedAt     DateTime
  
  // Response
  statusCode      Int?
  responseTime    Int?          // milliseconds
  success         Boolean
  error           String?
  
  // SSL
  sslExpiresAt    DateTime?
  sslValid        Boolean?
  
  // Response data
  responseHeaders Json?
  responseBody    String?       @db.Text
  
  monitor         Monitor       @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
  
  @@index([monitorId, createdAt])
  @@index([monitorId, success])
  @@map("checks")
}

model Incident {
  id              String        @id @default(uuid())
  monitorId       String
  userId          String
  
  status          IncidentStatus @default(OPEN)
  severity        Severity      @default(MEDIUM)
  
  title           String
  description     String?       @db.Text
  
  startedAt       DateTime      @default(now())
  resolvedAt      DateTime?
  acknowledgedAt  DateTime?
  acknowledgedBy  String?
  
  monitor         Monitor       @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  alerts          Alert[]
  
  @@index([monitorId, status])
  @@index([startedAt])
  @@map("incidents")
}

enum IncidentStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model AlertRule {
  id              String        @id @default(uuid())
  monitorId       String
  userId          String
  
  name            String
  enabled         Boolean       @default(true)
  
  // Conditions
  condition       AlertCondition
  threshold       Float?
  consecutiveFails Int?         @default(3)
  
  // Channels
  email           Boolean       @default(false)
  webhook         Boolean       @default(false)
  webhookUrl      String?
  sms             Boolean       @default(false)
  smsNumber       String?
  
  monitor         Monitor       @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@map("alert_rules")
}

enum AlertCondition {
  DOWN
  SLOW
  STATUS_CODE
  SSL_EXPIRY
  CUSTOM
}

model Alert {
  id              String        @id @default(uuid())
  incidentId      String
  
  channel         AlertChannel
  recipient       String
  status          AlertStatus   @default(PENDING)
  
  sentAt          DateTime?
  deliveredAt     DateTime?
  error           String?
  
  incident        Incident      @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
  
  @@index([incidentId])
  @@map("alerts")
}

enum AlertChannel {
  EMAIL
  WEBHOOK
  SMS
}

enum AlertStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

model StatusPage {
  id              String        @id @default(uuid())
  slug            String        @unique
  title           String
  description     String?       @db.Text
  public          Boolean       @default(false)
  
  monitorIds      String[]
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@map("status_pages")
}

model Metric {
  id              String        @id @default(uuid())
  name            String
  value           Float
  labels          Json?
  timestamp       DateTime      @default(now())
  
  @@index([name, timestamp])
  @@map("metrics")
}
